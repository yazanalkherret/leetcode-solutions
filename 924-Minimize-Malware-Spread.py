# Time Complexity: O(n^2)
# Space Complexity: O(n)

class UnionFind:
    def __init__(self, n, infectedSet):
        self.parent = [i for i in range(n)]
        self.rank = [1 for _ in range(n)]
        self.infectedNumber = [0] * n

        for i in range(n):
            if i in infectedSet:
                self.infectedNumber[i] = 1
        
    def find(self, v):
        res = v

        while res != self.parent[res]:
            self.parent[res] = self.parent[self.parent[res]]
            res = self.parent[res]

        return res

    def union(self, v1, v2):
        p1, p2 = self.find(v1), self.find(v2)

        if p1 == p2: return

        if self.rank[p1] >= self.rank[p2]:
            self.parent[p2] = p1
            self.rank[p1] += self.rank[p2]
            self.infectedNumber[p1] += self.infectedNumber[p2]
        else:
            self.parent[p1] = p2
            self.rank[p2] += self.rank[p1]
            self.infectedNumber[p2] += self.infectedNumber[p1]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = UnionFind(n, set(initial))

        # Connect Components
        # O(n^2 a(n)) -> O(n^2)
        for i in range(n):
            for j in range(n):
                if i == j: continue

                if graph[i][j] == 1:
                    uf.union(i, j)

        minheap = []
        # O(k log k + k a(n)) -> O(k log k)
        for infected in initial:
            component = uf.find(infected)
            size = uf.rank[component]
            if uf.infectedNumber[component] == 1:
                heapq.heappush(minheap, (-size, infected))

        return min(initial) if not minheap else heapq.heappop(minheap)[1]